services:
  mcp-obsidian:
    build:
      context: .
      dockerfile: Dockerfile
    image: archology/mcp-server-obsidian:local
    container_name: mcp_obsidian
    env_file:
      - .env
    environment:
      - OBSIDIAN_HOST=${OBSIDIAN_HOST}
      - OBSIDIAN_REST_API_URL=${OBSIDIAN_REST_API_URL}
      - OBSIDIAN_API_KEY=${OBSIDIAN_API_KEY}
      - MCP_PORT=${MCP_PORT}
    ports:
      - "${MCP_PORT:-3333}:${MCP_PORT:-3333}"
    restart: unless-stopped

  ngrok:
    image: ngrok/ngrok:latest
    container_name: mcp_obsidian_ngrok
    env_file:
      - .env
    depends_on:
      mcp-obsidian:
        condition: service_started
    entrypoint: []
    command:
      - /bin/sh
      - -c
      - |
        set -eu
        EXTRA_ARGS=""
        if [ -n "${NGROK_DOMAIN:-}" ]; then
          EXTRA_ARGS="$${EXTRA_ARGS} --domain=${NGROK_DOMAIN}"
        fi
        ngrok http --log=stdout --region=${NGROK_REGION:-us} $${EXTRA_ARGS} mcp-obsidian:${MCP_PORT:-3333}
    environment:
      - NGROK_AUTHTOKEN=${NGROK_AUTHTOKEN}
    restart: unless-stopped

  mcp-bridge:
    build:
      context: ./mcp-bridge
      dockerfile: Dockerfile
    container_name: mcp_bridge
    env_file:
      - .env
    environment:
      # Internal MCP endpoint (service-to-service, no ngrok)
      - MCP_ENDPOINT_URL=http://mcp-obsidian:${MCP_PORT:-3333}/mcp
      # Reuse your existing Obsidian REST URL var for the bridge
      - OBSIDIAN_REST_URL=${OBSIDIAN_REST_API_URL}
      - OBSIDIAN_API_KEY=${OBSIDIAN_API_KEY}
      # Try MCP first, then fall back to REST (set to "0" to force REST-only)
      - MCP_FIRST=1
    volumes:
      - ./mcp-bridge:/app
    ports:
      - "8787:8787"   # optional HTTP API: GET /query?q=boros
    depends_on:
      mcp-obsidian:
        condition: service_started
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8787/healthz"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s
