services:
  mcp-obsidian:
    build:
      context: .
      dockerfile: Dockerfile
    image: archology/mcp-server-obsidian:local
    container_name: mcp_obsidian
    env_file:
      - .env
    environment:
      - OBSIDIAN_HOST=${OBSIDIAN_HOST}
      - OBSIDIAN_REST_API_URL=${OBSIDIAN_REST_API_URL}
      - OBSIDIAN_API_KEY=${OBSIDIAN_API_KEY}
      - MCP_PORT=${MCP_PORT}
    ports:
      - "${MCP_PORT:-3333}:${MCP_PORT:-3333}"
    restart: unless-stopped
    # Healthcheck: Use the metrics health endpoint on port 8080
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s

  ngrok:
    image: ngrok/ngrok:latest
    container_name: mcp_ngrok
    env_file: [.env]
    depends_on:
      mcp-obsidian:
        condition: service_healthy
      mcp-bridge:
        condition: service_healthy
    volumes:
      - ./ngrok.yml:/ngrok.yml:ro
    entrypoint: []
    command: ["ngrok", "start", "--all", "--config", "/ngrok.yml", "--log", "stdout"]
    restart: unless-stopped

  mcp-bridge:
    build:
      context: ./bridge
      dockerfile: Dockerfile
    container_name: mcp_bridge
    env_file:
      - .env
    environment:
      # Internal MCP endpoint (service-to-service, no ngrok)
      - MCP_ENDPOINT_URL=http://mcp-obsidian:${MCP_PORT:-3333}/mcp
      # Reuse your existing Obsidian REST URL var for the bridge
      - OBSIDIAN_REST_URL=${OBSIDIAN_REST_API_URL}
      - OBSIDIAN_API_KEY=${OBSIDIAN_API_KEY}
      # Try MCP first, then fall back to REST (set to "0" to force REST-only)
      - MCP_FIRST=1
      - ARCOLOGY_MCP_KEY=${ARCOLOGY_MCP_KEY}
    volumes:
      - ./bridge:/app/bridge
    ports:
      - "8787:8787"   # optional HTTP API: GET /query?q=boros
    depends_on:
      mcp-obsidian:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8787/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 10s
